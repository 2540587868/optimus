package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"golang.org/x/tools/imports"
	"log"
	"os"
	"reflect"
	"strings"
	"text/template"
)

const optionTemplate = `//Code generated by optimus. DO NOT EDIT.
package {{.Package}}

import(
{{- range .Imports}}
		{{ . }}
{{- end }}
)

type {{.StructName }}Option func (*{{.StructName }})

//New{{ .StructName }} creates a new {{ .StructName }} with defaults and applies options.
func New{{ .StructName }}(opts ...{{ .StructName }}Option) *{{.StructName}} {
	c:=&{{	.StructName	}}	{
		{{- range .Fields }}
		{{- if .DefaultVal }}
		{{ .Name }}: {{ .DefaultVal }},
		{{- end }}
		{{- end }}
	}
	c.Apply(opts...)
	return c 
}


//Apply applies options to the config
func (c*{{.StructName }})Apply(opts...{{.StructName }}Option){
	for _,opt:=range opts{
		opt(c)
	}
}

{{range.Fields}}
{{- range .Comments }}
	{{ . }}
{{- end }}
{{- if .IsSlice}}
// {{ .Func }} appends values to {{ .Name }} slice.
func {{ .Func }}(v ...{{ .ParamType }}) {{ $.StructName }}Option {
	return func(c *{{ $.StructName }}) {
		c.{{ .Name }} = append(c.{{ .Name }}, v...)
	}
}
{{- else}}
// {{ .Func }} sets the {{ .Name }} field.
func {{ .Func }}(v {{ .Type }}) {{ $.StructName }}Option {
	return func(c *{{ $.StructName }}) {
		c.{{ .Name }} = v
	}
}
{{- end}}
{{ end }}
`

type FieldInfo struct {
	Name       string   // 字段名 (e.g. Host)
	Type       string   // 字段类型 (e.g. string)
	Func       string   // 生成的方法名 (e.g. WithHost 或 AddIP)
	ParamType  string   // 参数类型 (如果是切片，这里存元素类型)
	Comments   []string // 字段注释
	DefaultVal string   //默认值
	IsSlice    bool     // 是否是切片
}

type TemplateData struct {
	Package    string
	Imports    []string
	StructName string
	Fields     []FieldInfo
}

func main() {
	typePtr := flag.String("type", "", "struct name")
	flag.Parse()

	if *typePtr == "" {
		log.Fatal("Usage: go run main.go -type StructName")
	}

	goFile := os.Getenv("GOFILE")
	goPackage := os.Getenv("GOPACKAGE")

	if goFile == "" {
		log.Fatal("Please run via //go:generate")
	}

	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, goFile, nil, parser.ParseComments)
	if err != nil {
		log.Fatal(err)
	}

	var fields []FieldInfo
	var importLines []string
	found := false
	for _, imp := range node.Imports {
		var sb strings.Builder
		if imp.Name != nil {
			sb.WriteString(imp.Name.Name)
			sb.WriteString(" ")
		}
		sb.WriteString(imp.Path.Value)
		importLines = append(importLines, sb.String())
	}

	ast.Inspect(node, func(n ast.Node) bool {
		ts, ok := n.(*ast.TypeSpec)
		if !ok || ts.Name.Name != *typePtr {
			return true
		}

		st, ok := ts.Type.(*ast.StructType)
		if !ok {
			return true
		}

		found = true
		for _, field := range st.Fields.List {
			if len(field.Names) == 0 {
				continue
			}

			fieldName := field.Names[0].Name

			tagVal := ""
			defaultTag := ""
			if field.Tag != nil {
				cleanTag := strings.Trim(field.Tag.Value, "`")
				parsedTag := reflect.StructTag(cleanTag)
				tagVal = parsedTag.Get("opt")
				defaultTag = parsedTag.Get("default")
			}

			if tagVal == "-" {
				continue
			}

			typeStart := fset.Position(field.Type.Pos()).Offset
			typeEnd := fset.Position(field.Type.End()).Offset
			src, _ := os.ReadFile(goFile)
			fieldType := string(src[typeStart:typeEnd])

			defaultValCode := ""
			if defaultTag != "" {
				if fieldType == "string" {
					defaultValCode = fmt.Sprintf("%q", defaultTag)
				} else {
					// 对于 int, bool, float, time.Duration 等
					// 暂时直接信任用户写的代码，原样放进去
					// 比如 default:"100" -> 100
					// 比如 default:"30 * time.Second" -> 30 * time.Second
					defaultValCode = defaultTag
				}
			}

			var comments []string
			if field.Doc != nil {
				for _, c := range field.Doc.List {
					comments = append(comments, c.Text)
				}
			}

			isSlice := false
			paramType := fieldName
			funcName := "With" + fieldName

			if arrayType, ok := field.Type.(*ast.ArrayType); ok {
				isSlice = true
				funcName = "Add" + fieldName

				eltStart := fset.Position(arrayType.Elt.Pos()).Offset
				eltEnd := fset.Position(arrayType.Elt.End()).Offset
				paramType = string(src[eltStart:eltEnd])
			}

			if tagVal != "" {
				funcName = tagVal
			}

			fields = append(fields, FieldInfo{
				Name:       fieldName,
				Type:       fieldType,
				Func:       funcName,
				ParamType:  paramType,
				IsSlice:    isSlice,
				Comments:   comments,
				DefaultVal: defaultValCode,
			})
		}
		return false
	})

	if !found {
		log.Fatalf("Struct %s not found", *typePtr)
	}

	var buf bytes.Buffer
	tmpl := template.Must(template.New("opt").Parse(optionTemplate))
	err = tmpl.Execute(&buf, TemplateData{
		Package:    goPackage,
		StructName: *typePtr,
		Imports:    importLines,
		Fields:     fields,
	})
	if err != nil {
		log.Fatal(err)
	}

	outName := strings.ToLower(*typePtr) + "_options.go"
	formattedSource, err := imports.Process(outName, buf.Bytes(), nil)
	if err != nil {
		fmt.Println(buf.String())
		log.Fatalf("Failed to format generated code: %v", err)
	}

	err = os.WriteFile(outName, formattedSource, 0644)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Printf("Generated options for %s into %s\n", *typePtr, outName)
}
